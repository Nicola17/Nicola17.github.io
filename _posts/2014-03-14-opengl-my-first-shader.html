---
layout: post
title: OpenGL Sandbox - My first shader
date: '2014-03-14T22:06:00.001+01:00'
author: Nicola Pezzotti
tags:
- OpenGL
- C++
- Qt
- Computer graphics
modified_time: '2014-03-17T17:17:44.113+01:00'
thumbnail: http://2.bp.blogspot.com/-zTylQcOzStY/Ux-IismU19I/AAAAAAAABw4/KquCvlwCy4g/s72-c/teapotshading.png
blogger_id: tag:blogger.com,1999:blog-7911490130261214164.post-5636451049304166237
blogger_orig_url: http://diaryofatinker.blogspot.com/2014/03/opengl-my-first-shader.html
---

<div class="separator" style="clear: both; text-align: justify;">Here it is the rendering of the Utah Teapot and the Stanford Dragon rendered with my first shader.&nbsp;</div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-zTylQcOzStY/Ux-IismU19I/AAAAAAAABw4/KquCvlwCy4g/s1600/teapotshading.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-zTylQcOzStY/Ux-IismU19I/AAAAAAAABw4/KquCvlwCy4g/s1600/teapotshading.png" height="240" width="400" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-yZlc5r3PTho/Ux-IiyzwkwI/AAAAAAAABw8/-xWtwJt9k6Q/s1600/dragonshading.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-yZlc5r3PTho/Ux-IiyzwkwI/AAAAAAAABw8/-xWtwJt9k6Q/s1600/dragonshading.png" height="238" width="400" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><span style="text-align: justify;">It's a very simple shader and it does not create any light source in the scene. The depth perception is given by the coloration of the triangles. As you can see in the teapot image, each triangle is colored using a blend of the axes color given by the triangle's normal vector.</span><br /><span style="text-align: justify;"><br /></span><span style="text-align: justify;">The shader's code is straightforward:</span><br /><span style="text-align: justify;"><br /></span><script class="brush: c++" type="syntaxhighlighter"><![CDATA[ #version 330 core //Vertex shader in vec4 VertexPosition; in vec3 VertexNormal;  out vec4 Color;  void main(){     Color = vec4(normalize(abs(VertexNormal)),1.0);     gl_Position = gl_ModelViewProjectionMatrix * VertexPosition; } ]]></script> <script class="brush: c++" type="syntaxhighlighter"><![CDATA[ #version 330 core //Fragment shader  in vec4 Color;  out vec4 FragColor;  void main(){     FragColor = Color; } ]]></script><span style="text-align: justify;"><br /></span><span style="text-align: justify;">Here below the code which passes the vertex attributes to the shader is presented. <a href="http://qt-project.org/doc/qt-4.8/qtopengl.html">Qt helper classes</a> are a good choice in order to write quickly a more readable code. For this reason I will use this approach whenever it's possible</span><br /><span style="text-align: justify;"><br /></span> <script class="brush: c++" type="syntaxhighlighter"><![CDATA[ //Declaration     mutable QGLShaderProgram _program;     mutable QOpenGLVertexArrayObject _vao;     mutable QGLBuffer _verticesVbo;     mutable QGLBuffer _normalsVbo;  ]]></script> <script class="brush: c++" type="syntaxhighlighter"><![CDATA[ //Initialization     if(!_program.addShaderFromSourceFile(QGLShader::Vertex,"firsttest.vert"))         throw std::runtime_error("Unable to compile the vertex shader");     if(!_program.addShaderFromSourceFile(QGLShader::Fragment,"firsttest.frag"))         throw std::runtime_error("Unable to compile the fragment shader");     _program.link();      _program.bind();         _vao.bind();             _verticesVbo.create();             _verticesVbo.setUsagePattern(QGLBuffer::StaticDraw);             _verticesVbo.bind();                 _verticesVbo.allocate(&(_vertices[0]),                                       _vertices.size()*sizeof(vector_type));             _verticesVbo.release();              _normalsVbo.create();             _normalsVbo.setUsagePattern(QGLBuffer::StaticDraw);             _normalsVbo.bind();                 _verticesVbo.allocate(&(_normals[0]),                                       _normals.size()*sizeof(vector_type));             _normalsVbo.release();         _vao.release();      _program.release(); ]]></script> <script class="brush: c++" type="syntaxhighlighter"><![CDATA[ //Drawing     _program.bind();     _vao.bind();         _verticesVbo.bind();             _program.enableAttributeArray("VertexPosition");             _program.setAttributeBuffer("VertexPosition", GL_FLOAT, 0, 3 );         _verticesVbo.release();          _normalsVbo.bind();             _program.enableAttributeArray("VertexNormal");             _program.setAttributeBuffer("VertexNormal", GL_FLOAT, 0, 3 );         _normalsVbo.release();     glDrawArrays(GL_TRIANGLES, 0, _vertices.size());     _vao.release();     _program.release(); ]]></script>